#!/bin/bash

# Update environment configuration for PostgreSQL development

set -e

echo "ðŸ”§ Updating Environment for PostgreSQL Development"
echo "=================================================="

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m'

print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# Configuration
POSTGRES_USER="jamanager"
POSTGRES_PASSWORD="jamanager_dev_password"
POSTGRES_DB="jamanager_dev"
POSTGRES_PORT="5432"

# Create PostgreSQL connection URL
POSTGRES_URL="postgresql+asyncpg://$POSTGRES_USER:$POSTGRES_PASSWORD@localhost:$POSTGRES_PORT/$POSTGRES_DB"

print_status "Creating PostgreSQL environment configuration..."

# Create .env.postgres file
cat > .env.postgres << EOF
# PostgreSQL Development Environment
# Generated by mini-sprint-postgres setup

# Environment
ENVIRONMENT=development
DEBUG=true

# Database - PostgreSQL
DATABASE_URL=$POSTGRES_URL

# Security (development values)
SECRET_KEY=dev-secret-key-change-in-production
JAM_MANAGER_ACCESS_CODE=dev-access-code

# Performance
DATABASE_POOL_SIZE=10
CACHE_ENABLED=true
CACHE_DEFAULT_TTL=300
CACHE_MAX_SIZE=1000

# WebSocket
WEBSOCKET_ENABLED=true
WEBSOCKET_MAX_CONNECTIONS=100

# Monitoring
PROFILING_ENABLED=false
SLOW_QUERY_THRESHOLD=1.0

# Logging
LOG_LEVEL=DEBUG
EOF

print_success "Created .env.postgres file"

# Create backup of current .env if it exists
if [ -f ".env" ]; then
    print_status "Backing up current .env to .env.sqlite.backup"
    cp .env .env.sqlite.backup
fi

# Copy PostgreSQL config to .env
print_status "Updating .env file for PostgreSQL..."
cp .env.postgres .env

print_success "Environment updated for PostgreSQL"

echo ""
echo "ðŸ“‹ Environment Configuration:"
echo "  Database URL: $POSTGRES_URL"
echo "  Environment: development"
echo "  Debug: true"
echo "  Cache: enabled"
echo ""
echo "ðŸ”„ To switch back to SQLite:"
echo "  cp .env.sqlite.backup .env"
echo ""
echo "ðŸš€ Ready to test with PostgreSQL!"
